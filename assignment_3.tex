%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Programming/Coding Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
% This template uses a Perl script as an example snippet of code, most other
% languages are also usable. Configure them in the "CODE INCLUSION 
% CONFIGURATION" section.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{multicol} 

\usepackage{fancyvrb}

% redefine \VerbatimInput
\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}%
{
    fontsize=\footnotesize,
    %
    frame=lines,  % top and bottom rule only
    framesep=2em, % separation between frame and text
    rulecolor=\color{Gray},
    %
    label=\fbox{\color{Black}JavaImplementationOutput.txt},
    labelposition=topline,
    %
    commandchars=\|\(\), % escape character and argument delimiters for
    % commands within the verbatim
    commentchar=*        % comment character
}

\usepackage{quoting}
\quotingsetup{vskip=0pt}

\usepackage[plain]{algorithm}
\usepackage{algpseudocode}
\usepackage{subcaption}

\usepackage{mathtools}
\usepackage{amsmath, amsthm, amssymb}
\usepackage[ansinew]{inputenc}

\makeatletter
\renewcommand{\boxed}[1]{\text{\fboxsep=.2em\fbox{\m@th$\displaystyle#1$}}}
\makeatother

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkClass: \hmwkTitle} % Top center head
\rhead{}
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------

\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
\lstloadlanguages{Perl} % Load Perl syntax for listings, for a list of other languages supported see: ftp://ftp.tex.ac.uk/tex-archive/macros/latex/contrib/listings/listings.pdf
\lstset{language=Perl, % Use Perl in this example
        frame=single, % Single frame around code
        basicstyle=\small\ttfamily, % Use small true type font
        keywordstyle=[1]\color{Blue}\bf, % Perl functions bold and blue
        keywordstyle=[2]\color{Purple}, % Perl function arguments purple
        keywordstyle=[3]\color{Blue}\underbar, % Custom functions underlined and blue
        identifierstyle=, % Nothing special about identifiers                                         
        commentstyle=\usefont{T1}{pcr}{m}{sl}\color{MyDarkGreen}\small, % Comments small dark green courier font
        stringstyle=\color{Purple}, % Strings are purple
        showstringspaces=false, % Don't put marks in string spaces
        tabsize=5, % 5 spaces per tab
        %
        % Put standard Perl functions not included in the default language here
        morekeywords={rand},
        %
        % Put Perl function parameters here
        morekeywords=[2]{on, off, interp},
        %
        % Put user defined functions here
        morekeywords=[3]{test},
       	%
        morecomment=[l][\color{Blue}]{...}, % Line continuation (...) like blue comment
        numbers=left, % Line numbers on left
        firstnumber=1, % Line numbers start with line 1
        numberstyle=\tiny\color{Blue}, % Line numbers are blue and small
        stepnumber=5 % Line numbers go in steps of 5
}

% Creates a new command to include a perl script, the first parameter is the filename of the script (without .pl), the second parameter is the caption
\newcommand{\perlscript}[2]{
\begin{itemize}
\item[]\lstinputlisting[caption=#2,label=#1]{#1.pl}
\end{itemize}
}

%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Question \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
\stepcounter{homeworkProblemCounter} % Increase counter for number of problems
\renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the name of the problem
\section{\homeworkProblemName} % Make a section in the document with the custom problem count
\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
\exitProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}} % Makes the box around the problem answer and puts the content inside
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
\renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the name of the section from the environment argument
\subsection{\homeworkSectionName} % Make a subsection with the custom name of the subsection
\enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]} % Header and footer within the environment
}{
\enterProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Assignment\ \#3} % Assignment title
\newcommand{\hmwkDueDate}{Wednesday, 8\textsuperscript{th} of June, 2016} % Due date
\newcommand{\hmwkClass}{Fundamental Concepts of Cryptography} % Course/class
\newcommand{\hmwkClassTime}{Mid-day} % Class/lecture time
\newcommand{\hmwkClassInstructor}{Jones} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{Tim Cochrane} % Your name
\newcommand{\studentNum}{17766247}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\vspace{2in}
\textmd{\textbf{\hmwkClass}}\\
\textmd{\hmwkTitle}\\
\normalsize\vspace{0.1in}\small{\hmwkDueDate}\\
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName} \\ \studentNum}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document} 
\maketitle\thispagestyle{empty}

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

%  \newpage
%  \tableofcontents
%  \newpage

\clearpage
\setcounter{page}{1}

%----------------------------------------------------------------------------------------
%	PROBLEM 1
%----------------------------------------------------------------------------------------

% To have just one problem per page, simply put a \clearpage after each problem

\begin{homeworkProblem}

    a) Summarize the encryption techniques(DES and RSA) with emphasis on their advantages and disadvantages. \\

    \begin{quoting}

        DES and RSA take two fundamentally approaches when it comes to trying
        to encrypt a given message. Both have their advantages and
        disadvantages in different situations. \\

        DES is a block cipher, meaning it will accept blocks of plain text and
        output a block of cipher text. DES takes in 64 bit blocks and outputs
        an equivalent 64 bit block of cipher text. A typical key is also 64
        bits in size however only 56 bits of that is the actual key with 8
        being reserved for parity. This key is used on both the encryption and
        decryption process meaning DES is a symmetric encryption algorithm.
        During the encryption process the algorithm will perform 16 rounds of
        the Feistel function. The Feistel function accepts a half block and a
        subkey. The subkey is generated specifically for that round of the
        function. With these two it will perform a couple operations, an
        expansion, XOR, substitution and finally permutation.  All of these
        operations are rudimentary thus making DES a very fast encryption
        algorithm. \\

        RSA on the other hand is an asymmetric encryption algorithm meaning the
        keys used for encryption and decryption are different. To do this a
        key pair must be generated. A key pair is required for each party
        wishing to communicate and contains a public and a private key. The
        public key can be shared with the world while the private key must
        remain a secret. To send encrypt a message to someone you must encrypt
        the message you wish to send with the persons public key. The encrypted
        message can only be decrypted by the corresponding private key. The
        encryption algorithm use modular exponentiation of messages/keys in
        numeric form. These calculations can end up being very large with a
        typical key size today being 2048 bit. The calculations can be broken
        down into smaller pieces using modular arithmetic but the result of
        this is a very slow algorithm. The size of the message we can encrypt
        is at most the size of the key pair used. \\

        When comparing the two algorithms it's very clear to see the key size
        between the two is significantly different. DES only uses 56 bits
        compared to RSA which \textit{generally} uses 2048 bit. Obviously the
        larger the keysize the better in terms of how cryptographically secure
        the algorithm is. Currently it is considered impossible to crack RSA
        encryption using a keysize of 2048 bit using the computing power
        available however it's relatively trivial to crack a 56 bit DES
        encryption. Today DES is used in a form called triple DES where the
        plain text is encrypted three times with different keys each time, this
        is considered to be reasonably secure today. RSA has the obvious
        advantage over DES when it comes to the cryptographic security of the
        encrypted messages. \\
        
        As technology and techniques for breaking keys improves keysizes will
        eventually become insecure. Considering the abundance of cheap hard
        drive space today it's not expensive for an attacker to simply save
        your encrypted messages today and either spend a long time cracking the
        key (3DES) or wait for technology to reach a stage where that keysize
        is no longer secure (RSA). It's easy to conclude that the messages we
        encrypt today will not be secure forever. One advantage RSA has of
        DES/3DES is how easy it is to increase the key size, it's simply a
        matter of increasing the size of the primes you select. The larger the
        keysize you select the longer you can expect your messages to be
        secure. \\

        When trying to encrypt larger messages with DES we are able to break
        the message up into smaller 64 bit blocks and encrypt each separately.
        RSA will encrypt the entire message in one hit and can encrypt messages
        with a size as large as the keysize. Using the typical keysize of 2048
        we can in the best case encrypt 256 chars (\textit{This isn't possible
        given the way a message is structured, padding/random bits.}). These
        sizes are impractical when encrypting words as we can only really
        encrypt a paragraph or so. File encryption with RSA is practically out
        of the question. DES has the advantage of being able to encrypt files
        of any size. \\

        In public key encryption the public key is know by everyone. Because of
        this a potential attacker can encrypt messages using the publicly known
        key they can generate messages that they would expect to see and
        compare the cipher text they generate with what they are seeing over
        the network. To combat this we have to generate a random component to
        the message as well as pad the message out. DES has the advantage over
        RSA of as the key is only known by the two parties communicating,
        and because of this attackers cannot generate cipher texts with the
        key. \\

        Because DES is a symmetric encryption algorithm the same key is
        required on both sides to communicate. Somehow the two parties need to
        share the key with each other, often it's not possible to meet up to
        exchange the key every time we need one, thus we have to transmit it
        over the network. We must ensure the key is remains a secret, if it is
        revealed it would be trivial for an attacker to read all communications
        for the duration of that key. Because of the size of the internet and
        the shear number of different people we need to communicate with
        securely we simply cannot have a secure channel for each. RSA on the
        other hand simply requires a exchange of keys once, the keypair can be
        used for many years without any major security issue, once a keypair
        has been used it can be used to sign the new public key proving to
        everyone you had already shared with that you are still who you say you
        are. Ignoring \textit{Diffie Hellman} key exchange for the time being
        we can see that RSA has a massive advantage in terms of key exchange
        over DES. \\
    \end{quoting}

    b) List some main difficulties for key management of DES and RSA
    respectively and give your idea how to solve them. \\

    \begin{quoting}

        \textbf{DES Key Management} \\

        DES requires both parties have the same key before they are able to
        start communicating. There are a few ways that we can do this reliably
        even without access to a secure channel. The following two options are
        not the only options but simply the best without using a third party.
        \\

        The \textit{Diffie Hellman} key exchange protocol is an ingenious way
        to \textit{generate} a key that can be used between two parties. It
        requires both parties agree on two numbres, $p$ a prime number and $q$
        the primative root of $p$. These numbers are transmitted in plain text
        and are not required to be secret. From this both parties pick a
        private number less than the shared number $q$, this is their
        \textit{"private key"}, $X_{A}$. With this randomly selected number
        they each generate a \textit{"public key"}, $Y_{A}$, using the
        following formula: $p^{X_{A}} \text{ mod } q = Y_{A}$. Both $A$ and $B$
        will generate a public and private value and transmit the public one to
        the other party. With their private key and the other parties public
        key they can arrive at a common key using this formula: $K =
        (Y_{A})^{X_{B}} \text{ mod } q = (Y_{B})^{X_{A}} \text{ mod } q$ \\

        While this method is great as it doesn't require any prior sharing of
        keys before they are able to communicate it has one major flaw. An
        attacker that is able to intercept and modify messages between A and B
        could sit between the two and generate two keys using the protocol one
        for each A and B. Invisible to the original two parties the attacker
        can pretend to be the other party and relay the messages reading and/or
        changing anything they would like. To solve this man in the middle
        attack the two parties need some way of verifiying they are who they
        say they are. Combining the message signing capiabilities of RSA both
        parties could sign their public key numbers so each side could
            verify they are talking to the correct person. \textit{This solves
                the issue of verifying the other person however it just pushes
                to problem over to ensuring you have the correct public keys
            for each person. See discussion on RSA for more solutions.}

        In the previous situation, where we were signing the public keys in the
        Diffie Hellman key exchange, we would require both parties to have a
        keypair and know the others public key. At this point we have all of
        the requirements for RSA encryption and could simply transfer the key
        that way. While we could still do Diffie Hellman we could cut down on
        the number of messages required by having one host generate and send
        the key. This option is preferable because we get have secrecy of the
        message content as well as message signing to ensure we are talking to
        the correct person. \\

        \textbf{RSA Key Management} \\

        As discussed in the previous examples we were able to solve the key
        exchange problem by moving most of the work to RSA. But that doesn't
        solve the problem of ensuring we have the correct public key for the
        people we would like to communicate with. This is an issue that is very
        situation specific and given the large number of new services we are
        seeing on the internet is a very important topic. \\

        \textbf{HTTPS Example} \\

        Because anyone can generate a keypair and try and pass it off as
        someone elses we need to make sure with out a doubt that the public key
        we have is for the correct person. Using HTTPS as an example, both
        parties are able to get around this problem by using a trusted third
        party. The third party is called a \textit{Certificate Authority},
        their job is to sign the public key of the web server stating the
        correct domain name that it should be used for. This system works great
        and is the current method for ensuring that when you visit a https
        website we have the correct key. But for this method to work, we need
        to know the public key of all of the \textit{Certificate Authorities}
        and trust that the public key we have is the correct one for them. To
        get around this most browsers come preinstalled with a list of
        certified \textit{CA's} public keys. \\
        
        You will notice, if the website is using HTTPS without getting their
        public key signed by a recognized \textit{CA's} the browser will show a
        warning telling you the site you are connecting to is not
        \textit{"secure"}. What the browser really means is the public key
        cannot be verified and if you do infact have the correct public key your
        connection will be properly secure. \\

        \textbf{PGP/Email Encryption Example} \\

        Another situation where RSA can be used is for encrypting emails, a
        software package you can use for this is called PGP. When using PGP the
        encryption process if far more visibile to the user, as a result users
        will generally take a more hands on approch when trying to ensure that
        they public key they have is correct for the person they want to talk
        to. In the PGP community there are a couple ways the public keys are
        verified without the need for a third party authority to decide who's
        keys are valid. \\

        Meeting the person you wish to communicate with and exchanging public
        keys is the only way to be completely confident that the key you have
        is correct. Once you have met the person and exchanged keys, even later
        down the line if they need to change their keys you can be sure the new
        keys still belong to them if they sign their new public key with their
        old private key. Because it's not reasonable to meet up with every
        person you ever need to communicate with, it's common to use what is
        called a network of trust. What this means is that when you exchange
        public keys with someone in person you can sign their key stating that
        you trust that it is valid for that person. As more and more people
        sign each others public keys a network will build up. What this allows
        you to do is get the public key from a person you've never met
        \textit{reasonable} confidence assuming you have met someone who has
        signed their public key. This idea really starts to show the social
        aspect of cryptography and how really at the end of the day it's all
        one massive trust game.
    \end{quoting}

\end{homeworkProblem}

\begin{homeworkProblem}

    In page 36 of lecture 9, Please prove the verification stage for DSS. Make sure
    that you understand each step in your proof with detail comments for
    justification. For example, justify why $k^{-1} \text{ mod } q$ exists.

    \begin{align*}
        2^{L-1} &< p < 2^{L} \\
        \shortintertext{Where p is a prime number and L is a multiple of 64}
        2^{159} &< q < 2^{160} \\
        \shortintertext{Where q is the prime divisor of p - 1}
        g &= h^{\frac{p - 1}{q}} \text{ mod } p \\
        \shortintertext{Such that $1<h<p-1$ and $g > 1$}
        \text{Private Key } x &= 0 < x < q - 1 \\
        \shortintertext{Where x is a randomly chosen number.}
        \text{Public Key } y &= g^{x} \text{ mod } q \\
        \shortintertext{Select $K$ such that $0 < k < q$}
    \end{align*}
    \begin{align*}
        \shortintertext{Signing a message}
        r &= (g^{k} \text{ mod } p) \text{ mod } q \\
        s &= k^{-1}(H(m) + xr) \text{ mod } q
        \shortintertext{A signed message consists of:
        \begin{equation*}(m, r, s)\end{equation*}
        Where m is the message.}
    \end{align*}

    \begin{quoting}
        
    \end{quoting}

\end{homeworkProblem}

\begin{homeworkProblem}

    Consider a Diffie-Hillman scheme with a common prime q=13 and a primitive
root 7. \\

    a) If Alice has a public $X_{A} = 9$, what is Alice's private key? \\

    \begin{quoting}
        Because the numbers we have been given a quite small we can calculate
        Alice's private key but trying the integers from 0 to 12.
        \begin{align*}
            7^{0} \text{ mod } 13 &= 1 \\
            7^{1} \text{ mod } 13 &= 7 \\
            7^{2} \text{ mod } 13 &= 10 \\
            7^{3} \text{ mod } 13 &= 5 \\
            7^{4} \text{ mod } 13 &= 9
        \end{align*}

        We have found Alice's private key to be $X_{A} = 4$. \\

    \end{quoting}

    b) If Bob has a public key $X_{B} = 12$, please compute the common secret key $K$
shared with Alice. \\
    \begin{align*}
        K = (Y_{B})^{X_{A}} \text{ mod } 13 = 12^{4} \text{ mod } 13 = 1 \\
        \shortintertext{The key shared between A and B is 1.}
    \end{align*}

\end{homeworkProblem}

\end{document}
